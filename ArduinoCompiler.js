(function () {

    /*
        This script compiles Arduino C code from data that is generated by TweeParser.js.
        Author: Antti Ylikojola, https://www.github.com/AnttiYlikojola     
      
        Script has 3 main elements:

        1. Variable declaring for variables that are used in passages and booleans for tracking which passage is on
        2. Compiling passageVoids, the functions that has passage header, text and actions. (draws the passage UI and executes statements)
        3. Compiling if statements for button presses which are used to navigate in the story

        The script is executed by calling method "compileArduinoCode(storyObject)"

    */

    "use strict";

    const fs = require("fs");
    const cmd = require('node-cmd');

    const matchEquations = /(?:\$\w+|\d+) ?[><+*/-=]?(?: ?(?:\$\w+|\d+)?[><+*/-]?)*/g;
    const matchVariables = /(?:^|\W)\$(\w+)(?!\w)/g;

    let variableTracking = [];

    const resetScreen = `tft.reset();tft.fillScreen(BLACK);`;

    /* Helper functions for checking variable type */
    const isFloat = (n) => {
        if (String(n).split(".").length > 0) {
            return Number(n) === n && n % 1 !== 0;
        }
        return false;
    }
    const isBoolean = (bool) => {
        if (typeof (bool) == typeof (true) || typeof (bool) == typeof (false)) {
            return true;
        }
        return false;
    }
    /* 
        const passageVariables:

        Variable declarations
        declare every variable the story has so they can be later used anywhere in the code
        for example:
        "int counter;" 
        "char * stringVariable;"
        "float floatNumber;"

        Variables like "$a = $b + $c" can be defined by checking type of $b or $c in "variableTracking"-array of objects
        If $b or $c cant be found in the array, $a would be defined as string.

        If variable is not number, float or bool, it must be string.
        Harlowe has it's own compiler check which gives errors so it can be trusted that there is no errors in this part.

        TODO:
        Check if boolean value true/false (1/0) passes isInteger test
        Float types are hard to define because there is really no way to determine if 1.0 is float or int in javascript

    */
    const passageVariables = (sets) => {
        console.log("Compiling passageVariables");
        let variables = ``;
        let type;

        for (let i = 0; i < sets.length; i++) {
            if (Number.isInteger(Number(sets[i].value))) {
                type = `int `;
            } else if (isFloat(sets[i].value)) {
                type = `float `;
            } else if (isBoolean(sets[i].value)) {
                type = `bool `;
            } else if (typeof (sets[i].value === "string")) {
                if (sets[i].value.match(matchEquations) != null) {
                    let variable = /(?:^|\W)\$(\w+)(?!\w)/.exec(sets[i].value)[0].replace("$", "");
                    for (let o = 0; o < variableTracking.length; o++) {
                        if (variableTracking[o].variable === variable) {
                            type = variableTracking[o].type;
                            break;
                        }
                    }
                };
            } else if (typeof (sets[i].value === "string")) {
                type = `char * `;
            } else {
                console.log("VariableName " + sets[i].variableName + " type cant be determined...")
                alert("VariableName " + sets[i].variableName + " type cant be determined...")
            }
            variableTracking.push({ type: type, variable: sets[i].variableName, value: sets[i].value })
            variables += type + sets[i].variableName + ";\n";
        }
        return variables;
    };

    /*
        Declaring Booleans for tracking current passage 

        boolean of every passage in story
        defined as:

        "bool passageBool<passageName> = false;"
        by default this boolean is false, 
        when user navigates to passage, 
        that "passageboolean" will become true

        these boolean are used to track which passage player is currently on
        
        At the moment there can be maximum of two passages to navigate to (left and right button)

        if (leftButton){
            if(passageBoolkysymys){
            passageBooloikein = true;
            passageBoolkysymys = false;
            passageoikein();
        }
        if (rightButton){
            if(passageBoolkysymys){
            passageBoolvaarin = true;
            passageBoolkysymys = false;
            passagevaarin();
        }   
        
        In this example, current passage is "kysymys" -> passageBoolkysymys is true
        If user presses left button
        "kysymys" boolean becomes false 
        and "oikein" boolean becomes true, 
        after that program navigates to passage "oikein" and so on
    */
    const passageBooleans = (passages) => {
        console.log("Compiling passagebooleans");
        let booleans = ``;
        for (let i = 0; i < passages.length; i++) {
            booleans += `bool passageBool${passages[i].header} = false;\n`;
        }
        return booleans;
    };
    /* 
        Button actions will be inside arduino's void loop() method  (leftButton and rightButton selection)
        specific commentation of these buttons are in the comment above const passageBooleans()
    */
    const compileButtonCommands = (passageLinks) => {
        let leftButton = ``;
        let rightButton = ``;
        const rightIfButton = `p.z > MINPRESSURE && p.z < MAXPRESSURE && p.x > 160 && p.x < 290 && p.y < 930 && p.y > 560`;
        const leftIfButton = `p.z > MINPRESSURE && p.z < MAXPRESSURE && p.x > 160 && p.x < 290 && p.y < 560 && p.y > 120`;
        rightButton += `if(${rightIfButton}){`;
        leftButton += `if(${leftIfButton}){`;
        let elseOrIf = ``;
        for (let i = 0; i < passageLinks.length; i++) {
            elseOrIf = i === 0 ? `if` : `else if`;

            leftButton += `${elseOrIf}(passageBool${passageLinks[i].header}){`;
            leftButton += passageLinks[i].links[0] ? `passageBool${passageLinks[i].links[0]} = true;` : ``;
            leftButton += `passageBool${passageLinks[i].header} = false;`;
            leftButton += passageLinks[i].links[0] ? `passage${passageLinks[i].links[0]}();}` : `}`;

            rightButton += `${elseOrIf}(passageBool${passageLinks[i].header}){`;
            rightButton += passageLinks[i].links[1] ? `passageBool${passageLinks[i].links[1]} = true;` : ``;
            rightButton += `passageBool${passageLinks[i].header} = false;`;
            rightButton += passageLinks[i].links[1] ? `passage${passageLinks[i].links[1]}();}` : `}`;

        }
        rightButton += `}`;
        leftButton += `}`;

        return leftButton + rightButton;
    };
    /*
        Compiling if statement
        simply making string variable: 
        if(<statement.condition>){
            and here we call other statements by calling classifyStatement 
            switchcase function which returns actions or nested if statement
        }
    */
    const compileIfStatement = (statement) => {
        let ifStatement = `if(${statement.condition}){`;
        for (let i = 0; i < statement.conditionalActions.length; i++) {
            ifStatement += classifyStatement(statement.conditionalActions[i]);
        }
        ifStatement += `}`;
        return ifStatement;
    };
    /*
        Else statement works with same principle as if statement
    */
    const compileElseStatement = (statement) => {
        let elseStatement = `else{`;
        for (let i = 0; i < statement.conditionalActions.length; i++) {
            elseStatement += classifyStatement(statement.conditionalActions[i]);
        }
        elseStatement += `}`;
        return elseStatement;
    };

    /*
        Compiling set statement
        Simply returning string "<variableName> <operator>(= += -=) <value>"
        Variables have been declared earlier so no type needed here.
    */

    const compileSetStatement = (statement) => {
        console.log(`${statement.value.replace(/\$/g, "")};`)
        return `${statement.variable} ${statement.operator} ${statement.value.replace(/\$/g, "")};`;
    };

    /*
        Compiling goto-statement
        Setting passagebooleans so that the current boolean becomes false and the passage to be navigated to becomes false
        then simply call passage<passageName>(); to navigate to the passage 
    */
    const compileGotoStatement = (header, statement) => {
        return `passageBool${statement.value} = true;passage${statement.value}();`;
    };

    /*
        Compiling live statement (simply delaying before going for next execution)
        return delay(int);
    */
    const compileLiveStatement = (statement) => {
        return `delay(${statement.value});`
    };


    /*
        Passagetext contains story body
        Passage text can contain variables
        Variables are found with regex.
        If variables can be found
        we check variableTracking-array of objects for that variable and return variable value instead

        for example passage text could be:
        "How much is $a + $b"
        regex matches with $a and $b so match array would be [$a, $b]
        for loop iterates through match array and variableTracking array and checks if there is a match
        if match is found, $a is replaced with its value.


        let currentHeaderText; is for tracking passages header,
        if passage header is same as before, the text is printed few pixels below
        to prevent overlapping (adding +50 to cursorPositionY each call)

    */

    let currentHeaderText;
    let cursorPositionY;
    const compilePassageText = (header, statement) => {

        cursorPositionY = header == currentHeaderText ? cursorPositionY += 50 : 50;

        currentHeaderText = header;
        let statementText = statement.text;
        let variables = statementText.match(matchVariables) ? statementText.match(matchVariables) : null;
        if (variables) {
            for (let i = 0; i < variables.length; i++) {
                for (let o = 0; o < variableTracking.length; o++) {
                    console.log(variableTracking[o].variable)
                    if (variables[i].replace("$", "").replace(" ", "") == variableTracking[o].variable) {
                        console.log(variables[i])
                        var value = variableTracking[o].value;
                        break;
                    }
                    var value = null;
                }
                if (value) {
                    statementText = statementText.replace(variables[i], " " + value);
                }
            }
        }
        console.log(statementText)
        return `tft.fillRoundRect(160, 200, 160, 40, 8, RED); 
                tft.drawRoundRect(160, 200, 160, 40, 8, WHITE);
                tft.setCursor(15, ${cursorPositionY});
                tft.print("${statementText}");`;
    };

    /*
        Compiling link commands (buttons that user pressed to navigate in ui)
        Same as in passagetext, current header is tracked so the position of the text can be defined
    */
    let currentHeaderLink;
    /* Button option display */
    const compileLinkCommand = (header, statement) => {

        const horizontalAxis = currentHeaderLink === header ? 160 : 0;
        const horizontalCursor = currentHeaderLink === header ? 170 : 10;
        currentHeaderLink = header;
        let printableOption = statement.linkText ? (statement.linkText[0] == "$" ? statement.linkText.replace("$", "") : '"' + statement.linkText + '"') : statement.link;
        let linkButton = `tft.fillRoundRect(${horizontalAxis}, 200, 160, 40, 8, RED); 
                        tft.drawRoundRect(${horizontalAxis}, 200, 160, 40, 8, WHITE);
                        tft.setCursor(${horizontalCursor}, 210);
                        tft.print(${printableOption});`;

        return linkButton;
    };
    /*
      Compiling move statement (humanoid robots movements) 
    */
    const compileMoveStatement = (statement) => {
        return `fsm.transitionTo(state_${statement.transition});
                fsm.update();`;
    };

    /*
        Code inside arduino void loop()
        When user presses "Start story", first passage will be loaded
    */
    const loopCode = (firstPassage, buttonCode) => {
        const startButton = `p.z > MINPRESSURE && p.z < MAXPRESSURE && p.x < 850 && p.x > 250 && p.y < 600 && p.y > 500 && !storyStarted`;
        return `void loop(){
                    TSPoint p = ts.getPoint();
                    if (${startButton}) {
                        storyStarted = true;
                        passageBool${firstPassage} = true;
                        passage${firstPassage}();
                    }
                    ${buttonCode /* leftButton/rightButton code */}
                }`;
    };

    /*
        For example void <passageName>(){} includes everything that happens in one passage
    */
    const passageVoid = (passage) => {
        let passageFunction = `void passage${passage.header}(){`;
        passageFunction += resetScreen;
        /* Drawing passage header */
        passageFunction += `tft.fillRoundRect(0, 0, 320, 40, 8, RED);   //RGB led
                            tft.drawRoundRect(0, 0, 320, 40, 8, WHITE);
                            tft.fillRoundRect(0, 40, 320, 160, 8, RED);   //RGB led
                            tft.drawRoundRect(0, 40, 320, 160, 8, WHITE);
                            tft.setTextSize(2);
                            tft.setTextColor(YELLOW);
                            tft.setCursor(15, 15);
                            tft.print("${passage.header}");`
        /* */
        for (let i = 0; i < passage.passage.length; i++) {
            passageFunction += classifyStatement(passage.header, passage.passage[i]);
        }
        passageFunction += `}`;
        return passageFunction;
    }
    const classifyStatement = (header, passage) => {
        switch (passage.statement) {
            case "if:":
                return compileIfStatement(passage);
            case "elseif":
                return compileElseIfStatement(passage);
            case "else":
                return compileElseStatement(passage);
            case "live":
                return compileLiveStatement(passage);
            case "move":
                return compileMoveStatement(passage);
            case "goto":
                return compileGotoStatement(header, passage);
            case "set":
                return compileSetStatement(passage);
            case "passageText":
                return compilePassageText(header, passage);
            case "link":
                return compileLinkCommand(header, passage);
        }
    };
    /*
        Function that compiles the whole code

    */
    const compileArduinoCode = (tweeJSON) => {
        let passageLinks = [];
        let arduinoCode = ``
        arduinoCode += passageBooleans(tweeJSON); //compiling passageBooleans
        arduinoCode += passageVariables(tweeJSON.uniqueSets); // passageVariables, passing every unique set statement variable

        for (let i = 0; i < tweeJSON.length; i++) {
            arduinoCode += passageVoid(tweeJSON[i]); //passageVoids
            let passageLink = {
                header: tweeJSON[i].header,
                links: []
            };

            for (let ii = 0; ii < tweeJSON[i].passage.length; ii++) {
                if (tweeJSON[i].passage[ii].statement === "link") {
                    passageLink.links.push(tweeJSON[i].passage[ii].link);
                }
            }
            if (passageLink.links.length > 0) {
                passageLinks.push(passageLink);
            }
        }

        arduinoCode += loopCode(
            tweeJSON[0].header,
            compileButtonCommands(passageLinks)
        );

        insertToFile(arduinoCode);
    };
    module.exports = compileArduinoCode;

    const insertToFile = (codeString) => {
        console.log("Saving file...");
        let originalCode = fs.readFileSync('humanoid.ino').toString().split("\n");
        originalCode.splice(111, 0, codeString);
        let newCode = originalCode.join("\n");
        fs.writeFile('humanoid_new.ino', newCode, (err) => {
            if (err) return console.log(err);
            console.log("File saved...");
            upload();
        });
    };
    const upload = () => {
        console.log("Uploading to arduino...");
        cmd.get(
            `avrdude -p m2560 -P COM8 -c arduino -U flash:w:humanoid_new.ino -v`,
            (err, data, stderr) => {
                if (!err) {
                    console.log('arduino build succesfully :\n\n', data, stderr)
                } else {
                    console.log('error', err)
                }

            }
        );
    };
})();

